<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程懒人入门（八）:手把手教你写基于TCP的Socket长连接 | KNeegcyao</title><meta name="author" content="KNeegcyao"><meta name="copyright" content="KNeegcyao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="引言好多小白初次接触即时通讯（比如：IM或者消息推送应用）时，总是不能理解Web短连接（就是最常见的HTTP通信了）跟长连接（主要指TCP、UDP协议实现的socket通信，当然HTML5里的Websocket协议也是长连接）的区别，导致写即时通讯这类系统代码时往往找不到最佳实践，搞的一脸蒙逼。 本篇我们先简单了解一下 TCP&#x2F;IP，然后通过实现一个 echo 服务器来学习 Java 的">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程懒人入门（八）:手把手教你写基于TCP的Socket长连接">
<meta property="og:url" content="http://example.com/posts/36e4fc8d.html">
<meta property="og:site_name" content="KNeegcyao">
<meta property="og:description" content="引言好多小白初次接触即时通讯（比如：IM或者消息推送应用）时，总是不能理解Web短连接（就是最常见的HTTP通信了）跟长连接（主要指TCP、UDP协议实现的socket通信，当然HTML5里的Websocket协议也是长连接）的区别，导致写即时通讯这类系统代码时往往找不到最佳实践，搞的一脸蒙逼。 本篇我们先简单了解一下 TCP&#x2F;IP，然后通过实现一个 echo 服务器来学习 Java 的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg">
<meta property="article:published_time" content="2024-12-09T07:24:59.000Z">
<meta property="article:modified_time" content="2024-12-09T07:20:55.695Z">
<meta property="article:author" content="KNeegcyao">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/36e4fc8d.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'https://fancyapps.com/fancybox/',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程懒人入门（八）:手把手教你写基于TCP的Socket长连接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/15189043253972288);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/f351ca6264cb84d5053926824a04634af351ca6264cb84d5053926824a04634a);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" alt="Logo"><span class="site-name">KNeegcyao</span></a><a class="nav-page-title" href="/"><span class="site-name">网络编程懒人入门（八）:手把手教你写基于TCP的Socket长连接</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络编程懒人入门（八）:手把手教你写基于TCP的Socket长连接</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-09T07:20:55.695Z" title="更新于 2024-12-09 15:20:55">2024-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>好多小白初次接触即时通讯（比如：IM或者消息推送应用）时，总是不能理解Web短连接（就是最常见的HTTP通信了）跟长连接（主要指TCP、UDP协议实现的socket通信，当然HTML5里的Websocket协议也是长连接）的区别，导致写即时通讯这类系统代码时往往找不到最佳实践，搞的一脸蒙逼。</p>
<p>本篇我们先简单了解一下 TCP&#x2F;IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。</p>
<p>另外，本系列文章的前2篇《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1095-1-1.html">网络编程懒人入门(一)：快速理解网络通信协议（上篇）</a>》、《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1103-1-1.html">网络编程懒人入门(二)：快速理解网络通信协议（下篇）</a>》快速介绍了网络基本通信协议及理论基础，如果您对网络基础毫无概念，则请务必首先阅读完这2篇文章。本系列的第3篇文章《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1107-1-1.html">网络编程懒人入门(三)：快速理解TCP协议一篇就够</a>》有助于您快速理解TCP协议理论的方方面面，建议也可以读一读。</p>
<p>TCP 是互联网的核心协议之一，鉴于它的重要性，希望通过阅读上面介绍的几篇理论文章，再针对本文的动手实践，能真正加深您对TCP协议的理解。</p>
<p>如果您正打算系统地学习即时通讯开发，在读完本文后，建议您可以详细阅读《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-464-1-1.html">新手入门一篇就够：从零开发移动端IM</a>》。</p>
<h2 id="TCP-IP-协议简介"><a href="#TCP-IP-协议简介" class="headerlink" title="TCP&#x2F;IP 协议简介"></a>TCP&#x2F;IP 协议简介</h2><p>TCP&#x2F;IP协议族是互联网最重要的基础设施之一，如有兴趣了解TCP&#x2F;IP的贡献，可以读一读此文：《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-520-1-1.html">技术往事：改变世界的TCP&#x2F;IP协议（珍贵多图、手机慎点）</a>》，本文因篇幅原因仅作简要介绍。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>首先我们看 IP（Internet Protocol）协议。IP 协议提供了主机和主机间的通信。</p>
<p>为了完成不同主机的通信，我们需要某种方式来唯一标识一台主机，这个标识，就是著名的IP地址。通过IP地址，IP 协议就能够帮我们把一个数据包发送给对方。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>前面我们说过，IP 协议提供了主机和主机间的通信。TCP 协议在 IP 协议提供的主机间通信功能的基础上，完成这两个主机上进程对进程的通信。</p>
<p>有了 IP，不同主机就能够交换数据。但是，计算机收到数据后，并不知道这个数据属于哪个进程（简单讲，进程就是一个正在运行的应用程序）。TCP 的作用就在于，让我们能够知道这个数据属于哪个进程，从而完成进程间的通信。</p>
<p>为了标识数据属于哪个进程，我们给需要进行 TCP 通信的进程分配一个唯一的数字来标识它。这个数字，就是我们常说的端口号。</p>
<p>TCP 的全称是 Transmission Control Protocol，大家对它说得最多的，大概就是面向连接的特性了。之所以说它是有连接的，是说在进行通信前，通信双方需要先经过一个三次握手的过程。三次握手完成后，连接便建立了。这时候我们才可以开始发送&#x2F;接收数据。（与之相对的是 UDP，不需要经过握手，就可以直接发送数据）。</p>
<p><strong>下面我们简单了解一下三次握手的过程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151002hdgzhlenii040hga.png" alt="网络编程懒人入门(八)：手把手教你写基于TCP的Socket长连接_1.png"></p>
<ul>
<li>首先，客户向服务端发送一个 SYN，假设此时 sequence number 为 x。这个 x 是由操作系统根据一定的规则生成的，不妨认为它是一个随机数；</li>
<li>服务端收到 SYN 后，会向客户端再发送一个 SYN，此时服务器的 seq number &#x3D; y。与此同时，会 ACK x+1，告诉客户端“已经收到了 SYN，可以发送数据了”；</li>
<li>客户端收到服务器的 SYN 后，回复一个 ACK y+1，这个 ACK 则是告诉服务器，SYN 已经收到，服务器可以发送数据了。</li>
</ul>
<p><strong>经过这 3 步，TCP 连接就建立了，这里需要注意的有三点：</strong></p>
<ul>
<li>连接是由客户端主动发起的；</li>
<li>在第 3 步客户端向服务器回复 ACK 的时候，TCP 协议是允许我们携带数据的。之所以做不到，是 API 的限制导致的；</li>
<li>TCP 协议还允许 “四次握手” 的发生，同样的，由于 API 的限制，这个极端的情况并不会发生。</li>
</ul>
<p><strong>TCP&#x2F;IP 相关的理论知识我们就先了解到这里，如果对TCP的3次握手和4次挥手还不太理解，那就详细读读以下文章：</strong></p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-513-1-1.html">通俗易懂-深入理解TCP协议（上）：理论基础</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-515-1-1.html">通俗易懂-深入理解TCP协议（下）：RTT、滑动窗口、拥塞处理</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-258-1-1.html">理论经典：TCP协议的3次握手与4次挥手过程详解</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-275-1-1.html">理论联系实际：Wireshark抓包分析TCP 3次握手、4次挥手过程</a>》</li>
</ul>
<p>关于 TCP，还有诸如可靠性、流量控制、拥塞控制等非常有趣的特性。强烈推荐读者看一看 Richard 的名著《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html?mobile=no">TCP&#x2F;IP 详解 - 卷1</a>》（注意，是第1版，不是第2版）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151752f689f7wwbwhwr8ky.jpg" alt="网络编程懒人入门(八)：手把手教你写基于TCP的Socket长连接_2.jpg"></p>
<p>▲ 网络编程理论经典《TCP&#x2F;IP 详解 - 卷1》（<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html?mobile=no">在线阅读版点此进入</a>）</p>
<p>另外，TCP&#x2F;IP协议其实是一个庞大的协议族，《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-180-1-1.html">计算机网络通讯协议关系图（中文珍藏版）</a>》一文中为您清晰展现了这个协议族之间的关系，很有收藏价值，建议务必读一读。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151757n14c69vw566yuvb1.png" alt="网络编程懒人入门(八)：手把手教你写基于TCP的Socket长连接_3.png"></p>
<p>▲ TCP&#x2F;IP协议族图（<a target="_blank" rel="noopener" href="http://www.52im.net/thread-180-1-1.html">高清原图点此进入</a>）</p>
<p>下面我们看一些偏实战的东西。</p>
<h2 id="Socket-基本用法"><a href="#Socket-基本用法" class="headerlink" title="Socket 基本用法"></a>Socket 基本用法</h2><p>Socket 是 TCP 层的封装，通过 socket，我们就能进行 TCP 通信。</p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/api/javase-8u51/java/net/ServerSocket.html">ServerSocket</a> 和用于通信的 <a target="_blank" rel="noopener" href="http://docs.52im.net/extend/docs/api/javase-8u51/java/net/Socket.html">Socket</a>。</p>
<p><strong>使用 socket 的步骤如下：</strong></p>
<ul>
<li>1）创建 ServerSocket 并监听客户连接；</li>
<li>2）使用 Socket 连接服务端；</li>
<li>3）通过 Socket.getInputStream()&#x2F;getOutputStream() 获取输入输出流进行通信。</li>
</ul>
<p>下面，我们通过实现一个简单的 echo 服务来学习 socket 的使用。所谓的 echo 服务，就是客户端向服务端写入任意数据，服务器都将数据原封不动地写回给客户端。</p>
<h3 id="第一步：创建-ServerSocket-并监听客户连接"><a href="#第一步：创建-ServerSocket-并监听客户连接" class="headerlink" title="第一步：创建 ServerSocket 并监听客户连接"></a>第一步：创建 ServerSocket 并监听客户连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerSocket mServerSocket;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoServer</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建一个 ServerSocket 并监听端口 port</span></span><br><span class="line">        mServerSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 2. 开始接受客户连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> mServerSocket.accept();</span><br><span class="line">        handleClient(client);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleClient</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 使用 socket 进行通信 ...</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">EchoServer</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoServer</span>(<span class="number">9877</span>);</span><br><span class="line">            server.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步：使用-Socket-连接服务端"><a href="#第二步：使用-Socket-连接服务端" class="headerlink" title="第二步：使用 Socket 连接服务端"></a>第二步：使用 Socket 连接服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoClient</span><span class="params">(String host, <span class="type">int</span> port)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建 socket 并连接服务器</span></span><br><span class="line">        mSocket = <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 和服务端进行通信</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 由于服务端运行在同一主机，这里我们使用 localhost</span></span><br><span class="line">            <span class="type">EchoClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EchoClient</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9877</span>);</span><br><span class="line">            client.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步：通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信"><a href="#第三步：通过-socket-getInputStream-getOutputStream-获取输入-输出流进行通信" class="headerlink" title="第三步：通过 socket.getInputStream()&#x2F;getOutputStream() 获取输入&#x2F;输出流进行通信"></a>第三步：通过 socket.getInputStream()&#x2F;getOutputStream() 获取输入&#x2F;输出流进行通信</h3><p><strong>首先，我们来实现服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoServer</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleClient</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，服务端的实现其实很简单，我们不停地读取输入数据，然后写回给客户端。</p>
<p><strong>下面我们看看客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>::readResponse);</span><br><span class="line">        readerThread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> mSocket.getOutputStream();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = System.in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readResponse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> mSocket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.write(buffer, <span class="number">0</span>, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端会稍微复杂一点点，在读取用户输入的同时，我们又想读取服务器的响应。所以，这里创建了一个线程来读服务器的响应。</p>
<p><strong>不熟悉 lambda 的读者，可以把Thread readerThread &#x3D; new Thread(this::readResponse) 换成下面这个代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">readerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        readResponse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>打开两个 terminal 分别执行如下命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ javac EchoServer.java</span><br><span class="line">$ java EchoServer</span><br><span class="line"> </span><br><span class="line">$ javac EchoClient.java</span><br><span class="line">$ java EchoClient</span><br><span class="line">hello Server</span><br><span class="line">hello Server</span><br><span class="line">foo</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<p>在客户端，我们会看到，输入的所有字符都打印了出来。</p>
<h3 id="最后需要注意的有几点"><a href="#最后需要注意的有几点" class="headerlink" title="最后需要注意的有几点"></a>最后需要注意的有几点</h3><ul>
<li>1）在上面的代码中，我们所有的异常都没有处理。实际应用中，在发生异常时，需要关闭 socket，并根据实际业务做一些错误处理工作；</li>
<li>2）在客户端，我们没有停止 readThread。实际应用中，我们可以通过关闭 socket 来让线程从阻塞读中返回。推荐读者阅读《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">Java并发编程实战</a>》；</li>
<li>3）我们的服务端只处理了一个客户连接。如果需要同时处理多个客户端，可以创建线程来处理请求。这个作为练习留给读者来完全。</li>
</ul>
<h2 id="Socket、ServerSocket-傻傻分不清楚"><a href="#Socket、ServerSocket-傻傻分不清楚" class="headerlink" title="Socket、ServerSocket 傻傻分不清楚"></a>Socket、ServerSocket 傻傻分不清楚</h2><p><strong>在进入这一节的主题前，读者不妨先考虑一个问题：</strong>在上一节的实例中，我们运行 echo 服务后，在客户端连接成功时，一个有多少个 socket 存在？</p>
<p><strong>答案是 3 个 socket：</strong>客户端一个，服务端有两个。跟这个问题的答案直接关联的是本节的主题——Socket 和 ServerSocket 的区别是什么。</p>
<p><strong>眼尖的读者，可能会注意到在上一节我是这样描述他们的：</strong></p>
<p>在 Java 的 SDK 中，socket 的共有两个接口：用于监听客户连接的 ServerSocket 和用于通信的 Socket。</p>
<p><strong>注意：</strong>我只说 ServerSocket 是用于监听客户连接，而没有说它也可以用来通信。下面我们来详细了解一下他们的区别。</p>
<p><strong>注：</strong>以下描述使用的是 UNIX&#x2F;Linux 系统的 API。</p>
<p><strong>首先</strong>，我们创建 ServerSocket 后，内核会创建一个 socket。这个 socket 既可以拿来监听客户连接，也可以连接远端的服务。由于 ServerSocket 是用来监听客户连接的，紧接着它就会对内核创建的这个 socket 调用 listen 函数。这样一来，这个 socket 就成了所谓的 listening socket，它开始监听客户的连接。</p>
<p><strong>接下来</strong>，我们的客户端创建一个 Socket，同样的，内核也创建一个 socket 实例。内核创建的这个 socket 跟 ServerSocket 一开始创建的那个没有什么区别。不同的是，接下来 Socket 会对它执行 connect，发起对服务端的连接。前面我们说过，socket API 其实是 TCP 层的封装，所以 connect 后，内核会发送一个 SYN 给服务端。</p>
<p><strong>现在</strong>，我们切换角色到服务端。服务端的主机在收到这个 SYN 后，会创建一个新的 socket，这个新创建的 socket 跟客户端继续执行三次握手过程。</p>
<p>三次握手完成后，我们执行的 serverSocket.accept() 会返回一个 Socket 实例，这个 socket 就是上一步内核自动帮我们创建的。</p>
<p><strong>所以说：</strong>在一个客户端连接的情况下，其实有 3 个 socket。</p>
<p>关于内核自动创建的这个 socket，还有一个很有意思的地方。它的端口号跟 ServerSocket 是一毛一样的。咦！！不是说，一个端口只能绑定一个 socket 吗？其实这个说法并不够准确。</p>
<p>前面我说的TCP 通过端口号来区分数据属于哪个进程的说法，在 socket 的实现里需要改一改。Socket 并不仅仅使用端口号来区别不同的 socket 实例，而是使用 &lt;peer addr:peer port, local addr:local port&gt; 这个四元组。</p>
<p>在上面的例子中，我们的 ServerSocket 长这样：&lt;*:*, *:9877&gt;。意思是，可以接受任何的客户端，和本地任何 IP。</p>
<p>accept 返回的 Socket 则是这样：&lt;127.0.0.1:xxxx, 127.0.0.1:9877&gt;。其中，xxxx 是客户端的端口号。</p>
<p>如果数据是发送给一个已连接的 socket，内核会找到一个完全匹配的实例，所以数据准确发送给了对端。</p>
<p>如果是客户端要发起连接，这时候只有 &lt;*:*, *:9877&gt; 会匹配成功，所以 SYN 也准确发送给了监听套接字。</p>
<p>Socket&#x2F;ServerSocket 的区别我们就讲到这里。如果读者觉得不过瘾，可以参考《TCP&#x2F;IP 详解》<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html?mobile=no">卷1</a>、卷2。</p>
<h2 id="Socket-“长”连接的实现"><a href="#Socket-“长”连接的实现" class="headerlink" title="Socket “长”连接的实现"></a>Socket “长”连接的实现</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Socket 长连接，指的是在客户和服务端之间保持一个 socket 连接长时间不断开。</p>
<p><strong>比较熟悉 Socket 的读者，可能知道有这样一个 API：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>嗯……keep alive，“保持活着”，这个应该就是让 TCP 不断开的意思。那么，我们要实现一个 socket 的长连接，只需要这一个调用即可。</p>
<p>遗憾的是，生活并不总是那么美好。对于 4.4BSD 的实现来说，Socket 的这个 keep alive 选项如果打开并且两个小时内没有通信，那么底层会发一个心跳，看看对方是不是还活着。</p>
<p><strong>注意：</strong>两个小时才会发一次。也就是说，在没有实际数据通信的时候，我把网线拔了，你的应用程序要经过两个小时才会知道。</p>
<p>这个话题，对于即时通讯的老手来说，也就是经常讨论的“网络连接心跳保活”这个话题了，感兴趣的话可以读一读《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1493-1-1.html">聊聊iOS中网络编程长连接的那些事</a>》、《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-281-1-1.html">为何基于TCP协议的移动端IM仍然需要心跳保活机制？</a>》、《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-209-1-1.html">微信团队原创分享：Android版微信后台保活实战分享(网络保活篇)</a>》、《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-341-1-1.html">Android端消息推送总结：实现原理、心跳保活、遇到的问题等</a>》。</p>
<p>在说明如果实现长连接前，我们先来理一理我们面临的问题。</p>
<p><strong>假定现在有一对已经连接的 socket，在以下情况发生时候，socket 将不再可用：</strong></p>
<ul>
<li>1）某一端关闭是 socket（这不是废话吗）：主动关闭的一方会发送 FIN，通知对方要关闭 TCP 连接。在这种情况下，另一端如果去读 socket，将会读到 EoF（End of File）。于是我们知道对方关闭了 socket；</li>
<li>2）应用程序奔溃：此时 socket 会由内核关闭，结果跟情况1一样；</li>
<li>3）系统奔溃：这时候系统是来不及发送 FIN 的，因为它已经跪了。此时对方无法得知这一情况。对方在尝试读取数据时，最后会返回 read time out。如果写数据，则是 host unreachable 之类的错误。</li>
<li>4）电缆被挖断、网线被拔：跟情况3差不多，如果没有对 socket 进行读写，两边都不知道发生了事故。跟情况3不同的是，如果我们把网线接回去，socket 依旧可以正常使用。</li>
</ul>
<p>在上面的几种情形中，有一个共同点就是，只要去读、写 socket，只要 socket 连接不正常，我们就能够知道。基于这一点，要实现一个 socket 长连接，我们需要做的就是不断地给对方写数据，然后读取对方的数据，也就是所谓的<strong>心跳</strong>。只要心还在跳，socket 就是活的。写数据的间隔，需要根据实际的应用需求来决定。</p>
<p>心跳包不是实际的业务数据，根据通信协议的不同，需要做不同的处理。</p>
<p><strong>比方说，我们使用 JSON 进行通信，那么，可以为协议包加一个 type 字段，表面这个 JSON 是心跳还是业务数据：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="number">0</span>,  <span class="comment">// 0 表示心跳</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用二进制协议的情况类似。要求就是，我们能够区别一个数据包是心跳还是真实数据。这样，我们便实现了一个 socket 长连接。</p>
<h3 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h3><p>这一小节我们一起来实现一个带长连接的 Android echo 客户端。完整的代码可以在本文末尾的附件找到。</p>
<p><strong>首先了接口部分：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LongLiveSocket</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorCallback</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">onError</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataCallback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WritingCallback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongLiveSocket</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, WritingCallback callback)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len, WritingCallback callback)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这个支持长连接的类就叫 LongLiveSocket 好了。如果在 socket 断开后需要重连，只需要在对应的接口里面返回 true 即可（在真实场景里，我们还需要让客户设置重连的等待时间，还有读写、连接的 timeout等。为了简单，这里就直接不支持了。</p>
<p>另外需要注意的一点是，如果要做一个完整的库，需要同时提供阻塞式和回调式API。同样由于篇幅原因，这里直接省掉了。</p>
<p><strong>下面我们直接看实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LongLiveSocket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;LongLiveSocket&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">RETRY_INTERVAL_MILLIS</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HEART_BEAT_INTERVAL_MILLIS</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">HEART_BEAT_TIMEOUT_MILLIS</span> <span class="operator">=</span> <span class="number">2</span> * <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ErrorCallback</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果需要重连，返回 true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">onError</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataCallback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onData</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写数据回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WritingCallback</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span>;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mHost;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mPort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DataCallback mDataCallback;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ErrorCallback mErrorCallback;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HandlerThread mWriterThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mWriterHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mUIHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>(Looper.getMainLooper());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">mLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> Socket mSocket;  <span class="comment">// guarded by mLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mClosed; <span class="comment">// guarded by mLock</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mHeartBeatTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span>[] mHeartBeat = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 我们使用长度为 0 的数据作为 heart beat</span></span><br><span class="line">            write(mHeartBeat, <span class="keyword">new</span> <span class="title class_">WritingCallback</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">// 每隔 HEART_BEAT_INTERVAL_MILLIS 发送一次</span></span><br><span class="line">                    mWriterHandler.postDelayed(mHeartBeatTask, HEART_BEAT_INTERVAL_MILLIS);</span><br><span class="line">                    mUIHandler.postDelayed(mHeartBeatTimeoutTask, HEART_BEAT_TIMEOUT_MILLIS);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">                    <span class="comment">// nop</span></span><br><span class="line">                    <span class="comment">// write() 方法会处理失败</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">mHeartBeatTimeoutTask</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;mHeartBeatTimeoutTask#run: heart beat timeout&quot;</span>);</span><br><span class="line">        closeSocket();</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LongLiveSocket</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                          DataCallback dataCallback, ErrorCallback errorCallback)</span> &#123;</span><br><span class="line">        mHost = host;</span><br><span class="line">        mPort = port;</span><br><span class="line">        mDataCallback = dataCallback;</span><br><span class="line">        mErrorCallback = errorCallback;</span><br><span class="line"> </span><br><span class="line">        mWriterThread = <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;socket-writer&quot;</span>);</span><br><span class="line">        mWriterThread.start();</span><br><span class="line">        mWriterHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(mWriterThread.getLooper());</span><br><span class="line">        mWriterHandler.post(<span class="built_in">this</span>::initSocket);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (closed()) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(mHost, mPort);</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// 在我们创建 socket 的时候，客户可能就调用了 close()</span></span><br><span class="line">                    <span class="keyword">if</span> (mClosed) &#123;</span><br><span class="line">                        silentlyClose(socket);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mSocket = socket;</span><br><span class="line">                    <span class="comment">// 每次创建新的 socket，会开一个线程来读数据</span></span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReaderTask</span>(socket), <span class="string">&quot;socket-reader&quot;</span>);</span><br><span class="line">                    reader.start();</span><br><span class="line">                    mWriterHandler.post(mHeartBeatTask);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;initSocket: &quot;</span>, e);</span><br><span class="line">                <span class="keyword">if</span> (closed() || !mErrorCallback.onError()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(RETRY_INTERVAL_MILLIS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">                    <span class="comment">// interrupt writer-thread to quit</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, WritingCallback callback)</span> &#123;</span><br><span class="line">        write(data, <span class="number">0</span>, data.length, callback);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len, WritingCallback callback)</span> &#123;</span><br><span class="line">        mWriterHandler.post(() -&gt; &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> getSocket();</span><br><span class="line">            <span class="keyword">if</span> (socket == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// initSocket 失败而客户说不需要重连，但客户又叫我们给他发送数据</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Socket not initialized&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(outputStream);</span><br><span class="line">                out.writeInt(len);</span><br><span class="line">                out.write(data, offset, len);</span><br><span class="line">                callback.onSuccess();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;write: &quot;</span>, e);</span><br><span class="line">                closeSocket();</span><br><span class="line">                callback.onFail(data, offset, len);</span><br><span class="line">                <span class="keyword">if</span> (!closed() &amp;&amp; mErrorCallback.onError()) &#123;</span><br><span class="line">                    initSocket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">closed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mClosed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> Socket <span class="title function_">getSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> mSocket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">closeSocketLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSocket == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        silentlyClose(mSocket);</span><br><span class="line">        mSocket = <span class="literal">null</span>;</span><br><span class="line">        mWriterHandler.removeCallbacks(mHeartBeatTask);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Looper.getMainLooper() == Looper.myLooper()) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    doClose();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doClose</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mClosed = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 关闭 socket，从而使得阻塞在 socket 上的线程返回</span></span><br><span class="line">            closeSocketLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        mWriterThread.quit();</span><br><span class="line">        <span class="comment">// 在重连的时候，有个 sleep</span></span><br><span class="line">        mWriterThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">silentlyClose</span><span class="params">(Closeable closeable)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (closeable != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                closeable.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;silentlyClose: &quot;</span>, e);</span><br><span class="line">                <span class="comment">// error ignored</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ReaderTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket mSocket;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReaderTask</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">            mSocket = socket;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                readResponse();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;ReaderTask#run: &quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readResponse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="comment">// For simplicity, assume that a msg will not exceed 1024-byte</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> mSocket.getInputStream();</span><br><span class="line">            <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(inputStream);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nbyte</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">                <span class="keyword">if</span> (nbyte == <span class="number">0</span>) &#123;</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;readResponse: heart beat received&quot;</span>);</span><br><span class="line">                    mUIHandler.removeCallbacks(mHeartBeatTimeoutTask);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (nbyte &gt; buffer.length) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Receive message with len &quot;</span> + nbyte +</span><br><span class="line">                                    <span class="string">&quot; which exceeds limit &quot;</span> + buffer.length);</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="keyword">if</span> (readn(in, buffer, nbyte) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// Socket might be closed twice but it does no harm</span></span><br><span class="line">                    silentlyClose(mSocket);</span><br><span class="line">                    <span class="comment">// Socket will be re-connected by writer-thread if you want</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mDataCallback.onData(buffer, <span class="number">0</span>, nbyte);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">readn</span><span class="params">(InputStream in, <span class="type">byte</span>[] buffer, <span class="type">int</span> n)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> in.read(buffer, offset, n);</span><br><span class="line">                <span class="keyword">if</span> (readBytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// EoF</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                n -= readBytes;</span><br><span class="line">                offset += readBytes;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>下面是我们新实现的 EchoClient：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EchoClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;EchoClient&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongLiveSocket mLongLiveSocket;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EchoClient</span><span class="params">(String host, <span class="type">int</span> port)</span> &#123;</span><br><span class="line">        mLongLiveSocket = <span class="keyword">new</span> <span class="title class_">LongLiveSocket</span>(</span><br><span class="line">                host, port,</span><br><span class="line">                (data, offset, len) -&gt; Log.i(TAG, <span class="string">&quot;EchoClient: received: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, len)),</span><br><span class="line">                <span class="comment">// 返回 true，所以只要出错，就会一直重连</span></span><br><span class="line">                () -&gt; <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        mLongLiveSocket.write(msg.getBytes(), <span class="keyword">new</span> <span class="title class_">LongLiveSocket</span>.WritingCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">&quot;onSuccess: &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFail</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">int</span> offset, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">&quot;onFail: fail to write: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data, offset, len));</span><br><span class="line">                <span class="comment">// 连接成功后，还会发送这个消息</span></span><br><span class="line">                mLongLiveSocket.write(data, offset, len, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这样，一个带 socket 长连接的客户端就完成了。剩余代码跟我们这里的主题没有太大关系，感兴趣的读者可以看看文末附件里的源码或者自己完成这个例子。</p>
<p><strong>下面是一些输出示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">03:54:55.583 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:00.588 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:05.594 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:09.638 12691-12710/com.example.echo D/EchoClient: onSuccess:</span><br><span class="line">03:55:09.639 12691-12713/com.example.echo I/EchoClient: EchoClient: received: hello</span><br><span class="line">03:55:10.595 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:14.652 12691-12710/com.example.echo D/EchoClient: onSuccess:</span><br><span class="line">03:55:14.654 12691-12713/com.example.echo I/EchoClient: EchoClient: received: <span class="built_in">echo</span></span><br><span class="line">03:55:15.596 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:20.597 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line">03:55:25.602 12691-12713/com.example.echo I/LongLiveSocket: readResponse: heart beat received</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后需要说明的是，如果想节省资源，在有客户发送数据的时候可以省略 heart beat。</p>
<p>我们对读出错时候的处理，可能也存在一些争议。读出错后，我们只是关闭了 socket。socket 需要等到下一次写动作发生时，才会重新连接。实际应用中，如果这是一个问题，在读出错后可以直接开始重连。这种情况下，还需要一些额外的同步，避免重复创建 socket。heart beat timeout 的情况类似。</p>
<h2 id="跟-TCP-IP-学协议设计"><a href="#跟-TCP-IP-学协议设计" class="headerlink" title="跟 TCP&#x2F;IP 学协议设计"></a>跟 TCP&#x2F;IP 学协议设计</h2><p>如果仅仅是为了使用是 socket，我们大可以不去理会协议的细节。之所以推荐大家去看一看《<a target="_blank" rel="noopener" href="http://www.52im.net/topic-tcpipvol1.html?mobile=no">TCP&#x2F;IP 详解</a>》，是因为它们有太多值得学习的地方。很多我们工作中遇到的问题，都可以在这里找到答案。</p>
<p>以下每一个小节的标题都是一个小问题，建议读者独立思考一下，再继续往下看。</p>
<h3 id="协议版本如何升级？"><a href="#协议版本如何升级？" class="headerlink" title="协议版本如何升级？"></a>协议版本如何升级？</h3><p>有这么一句流行的话：这个世界唯一不变的，就是变化。当我们对协议版本进行升级的时候，正确识别不同版本的协议对软件的兼容非常重要。那么，我们如何设计协议，才能够为将来的版本升级做准备呢？</p>
<p>答案可以在 IP 协议找到。</p>
<p>IP 协议的第一个字段叫 version，目前使用的是 4 或 6，分别表示 IPv4 和 IPv6。由于这个字段在协议的开头，接收端收到数据后，只要根据第一个字段的值就能够判断这个数据包是 IPv4 还是 IPv6。</p>
<p>再强调一下，这个字段在两个版本的IP协议都位于第一个字段，为了做兼容处理，对应的这个字段必须位于同一位置。文本协议（如，JSON、HTML）的情况类似。</p>
<h3 id="如何发送不定长数据的数据包？"><a href="#如何发送不定长数据的数据包？" class="headerlink" title="如何发送不定长数据的数据包？"></a>如何发送不定长数据的数据包？</h3><p>举个例子，我们用微信发送一条消息。这条消息的长度是不确定的，并且每条消息都有它的边界。我们如何来处理这个边界呢？</p>
<p>还是一样，看看 IP。IP 的头部有个 header length 和 data length 两个字段。通过添加一个 len 域，我们就能够把数据根据应用逻辑分开。</p>
<p>跟这个相对的，还有另一个方案，那就是在数据的末尾放置终止符。比方说，想 C 语言的字符串那样，我们在每个数据的末尾放一个 \0 作为终止符，用以标识一条消息的尾部。这个方法带来的问题是，用户的数据也可能存在 \0。此时，我们就需要对用户的数据进行转义。比方说，把用户数据的所有 \0 都变成 \0\0。读消息的过程总，如果遇到 \0\0，那它就代表 \0，如果只有一个 \0，那就是消息尾部。</p>
<p>使用 len 字段的好处是，我们不需要对数据进行转义。读取数据的时候，只要根据 len 字段，一次性把数据都读进来就好，效率会更高一些。</p>
<p>终止符的方案虽然要求我们对数据进行扫描，但是如果我们可能从任意地方开始读取数据，就需要这个终止符来确定哪里才是消息的开头了。</p>
<p>当然，这两个方法不是互斥的，可以一起使用。</p>
<h3 id="上传多个文件，只有所有文件都上传成功时才算成功"><a href="#上传多个文件，只有所有文件都上传成功时才算成功" class="headerlink" title="上传多个文件，只有所有文件都上传成功时才算成功"></a>上传多个文件，只有所有文件都上传成功时才算成功</h3><p>现在我们有一个需求，需要一次上传多个文件到服务器，只有在所有文件都上传成功的情况下，才算成功。我们该如何来实现呢？</p>
<p>IP 在数据报过大的时候，会把一个数据报拆分成多个，并设置一个 MF （more fragments）位，表示这个包只是被拆分后的数据的一部分。</p>
<p>好，我们也学一学 IP。这里，我们可以给每个文件从 0 开始编号。上传文件的同时，也携带这个编号，并额外附带一个 MF 标志。除了编号最大的文件，所有文件的 MF 标志都置位。因为 MF 没有置位的是最后一个文件，服务器就可以根据这个得出总共有多少个文件。</p>
<p>另一种不使用 MF 标志的方法是，我们在上传文件前，就告诉服务器总共有多少个文件。</p>
<p>如果读者对数据库比较熟悉，学数据库用事务来处理，也是可以的。这里就不展开讨论了。</p>
<h3 id="如何保证数据的有序性？"><a href="#如何保证数据的有序性？" class="headerlink" title="如何保证数据的有序性？"></a>如何保证数据的有序性？</h3><p>这里讲一个我曾经遇到过的面试题。现在有一个任务队列，多个工作线程从中取出任务并执行，执行结果放到一个结果队列中。先要求，放入结果队列的时候，顺序顺序需要跟从工作队列取出时的一样（也就是说，先取出的任务，执行结果需要先放入结果队列）。</p>
<p>我们看看 TCP&#x2F;IP 是怎么处理的。IP 在发送数据的时候，不同数据报到达对端的时间是不确定的，后面发送的数据有可能较先到达。TCP 为了解决这个问题，给所发送数据的每个字节都赋了一个序列号，通过这个序列号，TCP 就能够把数据按原顺序重新组装。</p>
<p>一样，我们也给每个任务赋一个值，根据进入工作队列的顺序依次递增。工作线程完成任务后，在将结果放入结果队列前，先检查要放入对象的写一个序列号是不是跟自己的任务相同，如果不同，这个结果就不能放进去。此时，最简单的做法是等待，知道下一个可以放入队列的结果是自己所执行的那一个。但是，这个线程就没办法继续处理任务了。</p>
<p>更好的方法是，我们维护多一个结果队列的缓冲，这个缓冲里面的数据按序列号从小到大排序。</p>
<p><strong>工作线程要将结果放入，有两种可能：</strong></p>
<ul>
<li>1）刚刚完成的任务刚好是下一个，将这个结果放入队列。然后从缓冲的头部开始，将所有可以放入结果队列的数据都放进去；</li>
<li>2）所完成的任务不能放入结果队列，这个时候就插入结果队列。然后，跟上一种情况一样，需要检查缓冲。</li>
</ul>
<p>如果测试表明，这个结果缓冲的数据不多，那么使用普通的链表就可以。如果数据比较多，可以使用一个最小堆。</p>
<h3 id="如何保证对方收到了消息？"><a href="#如何保证对方收到了消息？" class="headerlink" title="如何保证对方收到了消息？"></a>如何保证对方收到了消息？</h3><p>我们说，TCP 提供了可靠的传输。这样不就能够保证对方收到消息了吗？</p>
<p>很遗憾，其实不能。在我们往 socket 写入的数据，只要对端的内核收到后，就会返回 ACK，此时，socket 就认为数据已经写入成功。然而要注意的是，这里只是对方所运行的系统的内核成功收到了数据，并不表示应用程序已经成功处理了数据。</p>
<p>解决办法还是一样，我们学 TCP，添加一个应用层的 APP ACK。应用接收到消息并处理成功后，发送一个 APP ACK 给对方。</p>
<p>有了 APP ACK，我们需要处理的另一个问题是，如果对方真的没有收到，需要怎么做？</p>
<p>TCP 发送数据的时候，消息一样可能丢失。TCP 发送数据后，如果长时间没有收到对方的 ACK，就假设数据已经丢失，并重新发送。</p>
<p>我们也一样，如果长时间没有收到 APP ACK，就假设数据丢失，重新发送一个。</p>
<p><strong>关于数据送达保证和应应答机制，以下文章进行了详细讨论：</strong></p>
<ul>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-294-1-1.html">IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-594-1-1.html">IM消息送达保证机制实现(二)：保证离线消息的可靠投递</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-753-1-1.html">IM群聊消息如此复杂，如何保证不丢不重？</a>》</li>
<li>《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1470-1-1.html">从客户端的角度来谈谈移动端IM的消息可靠性和送达机制</a>》</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">KNeegcyao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/36e4fc8d.html">http://example.com/posts/36e4fc8d.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">KNeegcyao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/4592bdf5.html" title="网络编程懒人入门（十六）:手把手教你使用网络编程抓包神器Wireshark"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">网络编程懒人入门（十六）:手把手教你使用网络编程抓包神器Wireshark</div></div><div class="info-2"><div class="info-item-1">引言跟网络通信有关的应用场景下（比如Web系统、IM聊天应用、消息推送系统等），经常要用到网络抓包工具，用以验证客户端和服务器之间收发的数据包是否正确。以IM聊天系统为例，TLS&#x2F;SSL加密开启到底有没有成功？加密效果怎么样？端到端加密后的聊天内容安全强度够不够？等等这些疑问，都需要通过网络抓包抓出样本来分析和验证。 Wireshark是一款开源和跨平台的抓包工具。它通过调用操作系统底层的API，直接捕获网卡上的数据包，因此捕获的数据包详细、功能强大。但Wireshark本身稍显复杂，本文将以用抓包实例，手把手带你一步步用好Wireshark，并真正理解抓到的数据包的各项含义。  ireshak的安装和基本使用安装：直接通过官方下载对应的安装包即可...</div></div></div></a><a class="pagination-related" href="/posts/d5420fc7.html" title="网络编程懒人入门（十四）:到底什么是Socket？一文即懂！"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络编程懒人入门（十四）:到底什么是Socket？一文即懂！</div></div><div class="info-2"><div class="info-item-1">引言本系列文章前面那些主要讲解的是计算机网络的理论基础，但对于即时通讯IM这方面的应用层开发者来说，跟计算机网络打道的其实是各种API接口。 本篇文章就来聊一下网络应用程序员最熟悉的Socket这个东西，抛开生涩的计算机网络理论，从应用层的角度来理解到底什么是Socket。 对于 Socket 的认识，本文将从以下几个方面着手介绍：  ***1）***Socket 是什么； ***2）***Socket 是如何创建的； ***3）***Socket 是如何连接的； ***4）***Socket 是如何收发数据的； ***5）***Socket 是如何断开连接的； ***6）***Socket 套接字的删除等。  特别说明：本文中提到的“Socket”、“网络套接字”、“套接字”，如无特殊指明，指的都是同一个东西哦。  *** 推荐阅读：**《深入操作系统，一文搞懂Socket到底是什么》一文也非常适合初学者。另一篇《我们在读写Socket时，究竟在读写什么？》，相信可进一步为你解惑。 Socket...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/6c92115f.html" title="Spring"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/20241206224728342.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">Spring</div></div><div class="info-2"><div class="info-item-1">Spring介绍Spring是一个IOC（DI）和AOP框架Spring的优良特性  ·非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API  ·依赖注入：DI是控制反转（IOC）最经典的实现  ·面向切面编程：AOP  ·组件化：Spring通过众多简单的组件配置组合成一个复杂应用  ·一站化：Spring提供了一系列框架，解决了应用开发中的众多问题 Spring模块划分  Spring-IOC容器组件和容器  ·组件：具有一定功能的对象。  ·容器：管理组件（创建，获取，保存，销毁）   可以将组件和容器的关系比喻成“房间”与“家具”的关系：   组件：可以看作是各种“家具”，比如桌子、椅子、灯、书架等。它们是构成界面或应用功能的基本元素，完成特定的功能任务，比如显示文本、输入数据等。  容器：则是“房间”或“空间”，用于装下各种家具。容器负责管理组件的布局、位置和相互之间的关系，同时也可能控制组件的生命周期和事件传递。  常见的容器：Servlet 容器（如 Tomcat、Jetty）：用于管理和运行 Java Web 应用，处理 HTTP...</div></div></div></a><a class="pagination-related" href="/posts/25b12d17.html" title="网络编程懒人入门（一）:快速理解网络通信协议（上篇）"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">网络编程懒人入门（一）:快速理解网络通信协议（上篇）</div></div><div class="info-2"><div class="info-item-1">正文引言我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol...</div></div></div></a><a class="pagination-related" href="/posts/a90dbf1.html" title="网络编程懒人入门（三）:快速理解TCP协议一篇就够"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">网络编程懒人入门（三）:快速理解TCP协议一篇就够</div></div><div class="info-2"><div class="info-item-1">前言本系列文章的前两篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》、《网络编程懒人入门(二)：快速理解网络通信协议（下篇）》快速介绍了网络基本通信协议及理论基础，建议开始阅读本文前先读完此2篇文章。 TCP 是互联网的核心协议之一，鉴于它的重要性，本文将单独介绍它的基础知识，希望能加深您对TCP协议的理解。 老规矩，为了让文字尽量通俗易懂、不浪费你的脑细胞，本文尽量点到为止，不对理论进行深入挖掘，如需深入理论细节，请参见下方参考资料中有关TCP协议的详细介绍和学习文章。 群神镇楼：  TCP 协议的作用互联网由一整套协议构成。TCP 只是其中的一层，有着自己的分工。  ▲ TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议 最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。  ▲ 以太网协议解决了局域网的点对点通信 但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。  ▲ IP 协议可以连接多个局域网 IP 协议定义了一套自己的地址规则，称为 IP...</div></div></div></a><a class="pagination-related" href="/posts/1750dad.html" title="网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势</div></div><div class="info-2"><div class="info-item-1">前言对于即时通讯开者新手来说，在开始着手编写IM或消息推送系统的代码前，最头疼的问题莫过于到底该选TCP还是UDP作为传输层协议。本文延续《网络编程懒人入门》系列文章的风格，通过快速对比分析 TCP 和 UDP...</div></div></div></a><a class="pagination-related" href="/posts/2de5e4a.html" title="网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？</div></div><div class="info-2"><div class="info-item-1">前言标题虽然是为了解释有了 IP 地址，为什么还要用 MAC 地址，但是本文的重点在于理解为什么要有 IP 这样的东西。本文对读者的定位是知道 MAC 地址是什么，IP 地址是什么。 关于作者 翟志军，个人博客地址：https://showme.codes/，Github：https://github.com/zacker330。感谢作者的原创分享。 书上说的*基本概念：* 如今的网络是分层来实现的，就像是搭积木一样，先设计某个特定功能的模块，然后把模块拼起来组成整个网络。局域网也不例外，一般来说，在组网上我们使用的是[IEEE802](https://baike.baidu.com/item/IEEE...</div></div></div></a><a class="pagination-related" href="/posts/7b1a8364.html" title="网络编程懒人入门（二）:快速理解网络通信协议（下篇）"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="info-item-2">网络编程懒人入门（二）:快速理解网络通信协议（下篇）</div></div><div class="info-2"><div class="info-item-1">前言本文上篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》分析了互联网的总体构思，从下至上，每一层协议的设计思想。基于知识连贯性的考虑，建议您先看完上篇后再来阅读本文。 本文从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 一个小结先对前面的内容，做一个小结（详见本文上篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》）。 我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。 数据包的结构，基本上是下面这样：  发送这个包，需要知道两个地址：  * 对方的MAC地址； *...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KNeegcyao</div><div class="author-info-description">记录coding！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KNeegcyao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/KNeegcyao" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangchao2903@163.com.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=322815684" target="_blank" title="云音乐"><i class="fa-solid fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP 协议简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.1.</span> <span class="toc-text">IP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.2.</span> <span class="toc-text">TCP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">Socket 基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA-ServerSocket-%E5%B9%B6%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.</span> <span class="toc-text">第一步：创建 ServerSocket 并监听客户连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%BD%BF%E7%94%A8-Socket-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text">第二步：使用 Socket 连接服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E9%80%9A%E8%BF%87-socket-getInputStream-getOutputStream-%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-number">3.3.</span> <span class="toc-text">第三步：通过 socket.getInputStream()&#x2F;getOutputStream() 获取输入&#x2F;输出流进行通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E6%9C%89%E5%87%A0%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">最后需要注意的有几点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E3%80%81ServerSocket-%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A"><span class="toc-number">4.</span> <span class="toc-text">Socket、ServerSocket 傻傻分不清楚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-%E2%80%9C%E9%95%BF%E2%80%9D%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.</span> <span class="toc-text">Socket “长”连接的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">背景知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">实现示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%9F-TCP-IP-%E5%AD%A6%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">跟 TCP&#x2F;IP 学协议设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">协议版本如何升级？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">如何发送不定长数据的数据包？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%BC%A0%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E9%83%BD%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%E6%97%B6%E6%89%8D%E7%AE%97%E6%88%90%E5%8A%9F"><span class="toc-number">6.3.</span> <span class="toc-text">上传多个文件，只有所有文件都上传成功时才算成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">如何保证数据的有序性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AF%B9%E6%96%B9%E6%94%B6%E5%88%B0%E4%BA%86%E6%B6%88%E6%81%AF%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">如何保证对方收到了消息？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a90dbf1.html" title="网络编程懒人入门（三）:快速理解TCP协议一篇就够"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程懒人入门（三）:快速理解TCP协议一篇就够"/></a><div class="content"><a class="title" href="/posts/a90dbf1.html" title="网络编程懒人入门（三）:快速理解TCP协议一篇就够">网络编程懒人入门（三）:快速理解TCP协议一篇就够</a><time datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1750dad.html" title="网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势"/></a><div class="content"><a class="title" href="/posts/1750dad.html" title="网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势">网络编程懒人入门（五）:快速理解为什么说UDP有时比TCP更有优势</a><time datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2de5e4a.html" title="网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？"/></a><div class="content"><a class="title" href="/posts/2de5e4a.html" title="网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？">网络编程懒人入门（九）:通俗讲解，有了IP地址，为何还要用MAC地址？</a><time datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b0dbfb54.html" title="网络编程懒人入门（七）:深入浅出，全面理解HTTP协议"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程懒人入门（七）:深入浅出，全面理解HTTP协议"/></a><div class="content"><a class="title" href="/posts/b0dbfb54.html" title="网络编程懒人入门（七）:深入浅出，全面理解HTTP协议">网络编程懒人入门（七）:深入浅出，全面理解HTTP协议</a><time datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/eb6629b4.html" title="网络编程懒人入门（六）:史上最通俗的集线器、交换机、路由器功能原理入门"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/fe81-a812480cc707e9a68269ec7e4bd1df80.jpg " onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网络编程懒人入门（六）:史上最通俗的集线器、交换机、路由器功能原理入门"/></a><div class="content"><a class="title" href="/posts/eb6629b4.html" title="网络编程懒人入门（六）:史上最通俗的集线器、交换机、路由器功能原理入门">网络编程懒人入门（六）:史上最通俗的集线器、交换机、路由器功能原理入门</a><time datetime="2024-12-09T07:24:59.000Z" title="发表于 2024-12-09 15:24:59">2024-12-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/f351ca6264cb84d5053926824a04634af351ca6264cb84d5053926824a04634a);"><div id="footer-wrap"><div class="copyright">&copy;2024 By KNeegcyao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.8" zIndex="-1" count="200" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="Java,Spring,k8s,MVC,Redis,Mysql,JVM,Maven,Docker" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
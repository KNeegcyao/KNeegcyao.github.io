<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>网络编程懒人入门(七):深入浅出，全面理解HTTP协议 | KNeegcyao</title><meta name="author" content="KNeegcyao"><meta name="copyright" content="KNeegcyao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 对于移动端即时通讯（尤其IM应用）来说，现今主流的数据通信总结下来无外乎就是长连接+短连接的方式，而短连接在应用上讲就是本文将要介绍的HTTP协议的应用，而而正">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程懒人入门(七):深入浅出，全面理解HTTP协议">
<meta property="og:url" content="http://example.com/posts/b0dbfb54.html">
<meta property="og:site_name" content="KNeegcyao">
<meta property="og:description" content="前言HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 对于移动端即时通讯（尤其IM应用）来说，现今主流的数据通信总结下来无外乎就是长连接+短连接的方式，而短连接在应用上讲就是本文将要介绍的HTTP协议的应用，而而正">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2024-12-03T06:25:05.000Z">
<meta property="article:modified_time" content="2024-12-10T13:50:11.468Z">
<meta property="article:author" content="KNeegcyao">
<meta property="article:tag" content="基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/posts/b0dbfb54.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: '//github.com/francoischalifour/medium-zoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '网络编程懒人入门(七):深入浅出，全面理解HTTP协议',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/15189043253972288);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/f351ca6264cb84d5053926824a04634af351ca6264cb84d5053926824a04634a);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" alt="Logo"><span class="site-name">KNeegcyao</span></a><a class="nav-page-title" href="/"><span class="site-name">网络编程懒人入门(七):深入浅出，全面理解HTTP协议</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">网络编程懒人入门(七):深入浅出，全面理解HTTP协议</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-03T06:25:05.000Z" title="发表于 2024-12-03 14:25:05">2024-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-10T13:50:11.468Z" title="更新于 2024-12-10 21:50:11">2024-12-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/b0dbfb54.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HTTP（全称超文本传输协议，英文全称HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
<p>对于移动端即时通讯（尤其IM应用）来说，现今主流的数据通信总结下来无外乎就是长连接+短连接的方式，而短连接在应用上讲就是本文将要介绍的HTTP协议的应用，而而正确地理解HTTP协议对于写好IM来说，是相当有益的（关于移动端的HTTP具体应用情况，可以阅读《<a target="_blank" rel="noopener" href="http://www.52im.net/thread-1413-1-1.html">现代移动端网络短连接的优化手段总结：请求速度、弱网适应、安全保障</a>》）。</p>
<h2 id="“HTTP之父”其人"><a href="#“HTTP之父”其人" class="headerlink" title="“HTTP之父”其人"></a>“HTTP之父”其人</h2><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/144336adhfhh6ao1dfj9hj.jpeg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpeg"></p>
<p>▲ “HTTP之父”——Ted Nelson</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/145008qo2kxxx5cp50y4pc.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_0ff41bd5ad6eddc4ef6d98a639dbb6fd536633e0.png"></p>
<p>▲ HTTP协议logo</p>
<p>1960年Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。</p>
<p>Ted Nelson组织协调万维网协会（World Wide Web Consortium）和Internet工作小组（Internet Engineering Task Force）共同合作研究，最终发布了一系列的RFC，其中最著名的就是<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616">RFC 2616</a>。RFC 2616定义了HTTP协议的我们今天普遍使用的一个版本——HTTP 1.1。</p>
<p>由于Ted Nelson对HTTP技术的发展做出的突破性历史贡献，他被称为“HTTP之父”。</p>
<h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><h3 id="计算机网络体系结构分层"><a href="#计算机网络体系结构分层" class="headerlink" title="计算机网络体系结构分层"></a>计算机网络体系结构分层</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/145919yh0x5j58qohs22sa.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.png"></p>
<h3 id="TCP-IP-通信传输流"><a href="#TCP-IP-通信传输流" class="headerlink" title="TCP&#x2F;IP 通信传输流"></a>TCP&#x2F;IP 通信传输流</h3><p>利用 TCP&#x2F;IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。</p>
<p><strong>TCP&#x2F;IP 通信传输流如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/145950pbabmd4qwd6c61zn.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.png"></p>
<ul>
<li>首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求；</li>
<li>接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层；</li>
<li>在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了；</li>
<li>接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。</li>
</ul>
<p><strong>HTTP 请求如下图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/150028yd5rdd9ty7tg09tc.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.png"></p>
<p>在网络体系结构中，包含了众多的网络协议，这篇文章主要围绕 HTTP 协议（HTTP&#x2F;1.1版本）展开。</p>
<p>HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传输协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<p>HTTP是客户端浏览器或其他程序与Web服务器之间的应用层通信协议。在Internet上的Web服务器上存放的都是超文本信息，客户机需要通过HTTP协议传输所要访问的超文本信息。HTTP包含命令和传输信息，不仅可用于Web访问，也可以用于其他因特网&#x2F;内联网应用系统之间的通信，从而实现各类应用资源超媒体访问的集成。</p>
<p>我们在浏览器的地址栏里输入的网站地址叫做URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。当你在浏览器的地址框中输入一个URL或是单击一个超级链接时，URL就确定了要浏览的地址。浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码提取出来，并翻译成漂亮的网页。</p>
<h2 id="HTTP-工作过程"><a href="#HTTP-工作过程" class="headerlink" title="HTTP 工作过程"></a>HTTP 工作过程</h2><p><strong>HTTP请求响应模型：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/150222j96nx292xu7nwz87.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.jpg"></p>
<p><strong>HTTP通信机制是在一次完整的 HTTP 通信过程中，客户端与服务器之间将完成下列7个步骤：</strong></p>
<ul>
<li><em><strong>1</strong></em>.建立 TCP 连接：在HTTP工作开始之前，客户端首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP&#x2F;IP 协议族，因此 Internet 又被称作是 TCP&#x2F;IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则，只有低层协议建立之后，才能进行高层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是80；</li>
<li><em><strong>2</strong></em>.客户端向服务器发送请求命令：一旦建立了TCP连接，客户端就会向服务器发送请求命令；<br>例如：GET&#x2F;sample&#x2F;hello.jsp HTTP&#x2F;1.1；</li>
<li><em><strong>3</strong></em>.客户端发送请求头信息：客户端发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，之后客户端发送了一空白行来通知服务器，它已经结束了该头信息的发送；</li>
<li><em><strong>4</strong></em>.服务器应答：客户端向服务器发出请求后，服务器会客户端返回响应；<br>例如： HTTP&#x2F;1.1 200 OK<br>响应的第一部分是协议的版本号和响应状态码；</li>
<li><em><strong>5</strong></em>.服务器返回响应头信息：正如客户端会随同请求发送关于自身的信息一样，服务器也会随同响应向用户发送关于它自己的数据及被请求的文档；</li>
<li><em><strong>6</strong></em>.服务器向客户端发送数据：服务器向客户端发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 响应头信息所描述的格式发送用户所请求的实际数据；</li>
<li><em><strong>7</strong></em>.服务器关闭 TCP 连接：一般情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接，然后如果客户端或者服务器在其头信息加入了这行代码 Connection:keep-alive ，TCP 连接在发送后将仍然保持打开状态，于是，客户端可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li>
</ul>
<h2 id="HTTP-协议基础"><a href="#HTTP-协议基础" class="headerlink" title="HTTP 协议基础"></a>HTTP 协议基础</h2><h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><p>应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色。仅从一条通信线路来说，服务器端和客服端的角色是确定的。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<h3 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h3><p>HTTP 是一种无状态协议。协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。<br>可是随着 Web 的不断发展，我们的很多业务都需要对通信状态进行保存。于是我们引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>
<h3 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h3><p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<p><strong>Cookie 的流程：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/150708wk6wefkkxs8gzwpq.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.jpg"></p>
<h3 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h3><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>
<h3 id="告知服务器意图的-HTTP-方法（HTTP-1-1）"><a href="#告知服务器意图的-HTTP-方法（HTTP-1-1）" class="headerlink" title="告知服务器意图的 HTTP 方法（HTTP&#x2F;1.1）"></a>告知服务器意图的 HTTP 方法（HTTP&#x2F;1.1）</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/150738p93ccmc9gwcwvo5e.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_6.png"></p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>HTTP 协议的初始版本中，每进行一个 HTTP 通信都要断开一次 TCP 连接。比如使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无畏的 TCP 连接建立和断开，增加通信量的开销。</p>
<p>为了解决上述 TCP 连接的问题，HTTP&#x2F;1.1 和部分 HTTP&#x2F;1.0 想出了持久连接的方法。其特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。旨在建立一次 TCP 连接后进行多次请求和响应的交互。在 HTTP&#x2F;1.1 中，所有的连接默认都是持久连接。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化方式发送成为可能。以前发送请求后需等待并接收到响应，才能发送下一个请求。管线化技术出现后，不用等待亦可发送下一个请求。这样就能做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>
<p>比如，当请求一个包含多张图片的 HTML 页面时，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术要比持久连接速度更快。请求数越多，时间差就越明显。</p>
<h2 id="HTTP-协议报文结构"><a href="#HTTP-协议报文结构" class="headerlink" title="HTTP 协议报文结构"></a>HTTP 协议报文结构</h2><h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的 HTTP 报文叫做请求报文；响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。</p>
<h3 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h3><p>HTTP 报文大致可分为报文首部和报文主体两部分。两者由最初出现的空行（CR+LF）来划分。通常，并不一定有报文主体。</p>
<p><strong>HTTP 报文结构如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151056wzsxtx0ziahtx8ee.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_8.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151033dx8srrfg2dy9ls9e.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_7.png"></p>
<h3 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151158q8elt791i3j9nb7n.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_8.jpg"></p>
<p><strong>请求报文的首部内容由以下数据组成：</strong></p>
<ul>
<li>请求行 —— 包含用于请求的方法、请求 URI 和 HTTP 版本；</li>
<li>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、请求首部、实体首部以及RFC里未定义的首部如 Cookie 等）。</li>
</ul>
<p><strong>请求报文的示例，如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151234eayhzahhhb9bez90.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_9.png"></p>
<h3 id="响应报文结构"><a href="#响应报文结构" class="headerlink" title="响应报文结构"></a>响应报文结构</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151401efh295x58hh5pko7.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_10.jpg"></p>
<p><strong>响应报文的首部内容由以下数据组成：</strong></p>
<ul>
<li>状态行 —— 包含表明响应结果的状态码、原因短语和 HTTP 版本；</li>
<li>首部字段 —— 包含表示请求的各种条件和属性的各类首部。（通用首部、响应首部、实体首部以及RFC里未定义的首部如 Cookie 等）。</li>
</ul>
<p><strong>响应报文的示例，如下：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/151423xyb4bb56o4k9gz4x.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_11.png"></p>
<h2 id="HTTP-报文首部之首部字段（重点分析）"><a href="#HTTP-报文首部之首部字段（重点分析）" class="headerlink" title="HTTP 报文首部之首部字段（重点分析）"></a>HTTP 报文首部之首部字段（重点分析）</h2><h3 id="首部字段概述"><a href="#首部字段概述" class="headerlink" title="首部字段概述"></a>首部字段概述</h3><p>先来回顾一下首部字段在报文的位置，HTTP 报文包含报文首部和报文主体，报文首部包含请求行（或状态行）和首部字段。<br>在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。使用首部字段是为了给客服端和服务器端提供报文主体大小、所使用的语言、认证信息等内容。</p>
<h3 id="首部字段结构"><a href="#首部字段结构" class="headerlink" title="首部字段结构"></a>首部字段结构</h3><p>HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“：”分隔。</p>
<p>另外，字段值对应单个 HTTP 首部字段可以有多个值。</p>
<p>当 HTTP 报文首部中出现了两个或以上具有相同首部字段名的首部字段时，这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，优先处理的顺序可能不同，结果可能并不一致。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/152935er9b66v6us2rbsac.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.jpg"></p>
<h3 id="首部字段类型"><a href="#首部字段类型" class="headerlink" title="首部字段类型"></a>首部字段类型</h3><p>首部字段根据实际用途被分为以下4种类型：</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/153008a7jki7ivixcw7ijj.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpg"></p>
<h3 id="通用首部字段（HTTP-1-1）"><a href="#通用首部字段（HTTP-1-1）" class="headerlink" title="通用首部字段（HTTP&#x2F;1.1）"></a>通用首部字段（HTTP&#x2F;1.1）</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/153032tqbab87889qdabbj.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.jpg"></p>
<h3 id="请求首部字段（HTTP-1-1）"><a href="#请求首部字段（HTTP-1-1）" class="headerlink" title="请求首部字段（HTTP&#x2F;1.1）"></a>请求首部字段（HTTP&#x2F;1.1）</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/153318a11rkbhi22rich80.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.jpg"></p>
<h3 id="响应首部字段（HTTP-1-1）"><a href="#响应首部字段（HTTP-1-1）" class="headerlink" title="响应首部字段（HTTP&#x2F;1.1）"></a>响应首部字段（HTTP&#x2F;1.1）</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/155106x0bg06gkrokbs6yg.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpg"></p>
<h3 id="实体首部字段（HTTP-1-1）"><a href="#实体首部字段（HTTP-1-1）" class="headerlink" title="实体首部字段（HTTP&#x2F;1.1）"></a>实体首部字段（HTTP&#x2F;1.1）</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/155133hujvpueukugvd4zk.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.jpg"></p>
<h3 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/155206fekigcvwgevitqka.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.jpg"></p>
<h2 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h2><p>HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。以下是最为常用的首部字段。</p>
<p><strong>X-Frame-Options：</strong><br>X-Frame-Options: DENY 首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值：</p>
<ul>
<li>DENY：拒绝；</li>
<li>SAMEORIGIN：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a target="_blank" rel="noopener" href="http://sample.com/sample.html">http://sample.com/sample.html</a> 页面为 SAMEORIGIN 时，那么 sample.com 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）。</li>
</ul>
<p><strong>X-XSS-Protection：</strong><br>X-XSS-Protection: 1 首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下:</p>
<ul>
<li>0 ：将 XSS 过滤设置成无效状态</li>
<li>1 ：将 XSS 过滤设置成有效状态</li>
</ul>
<p><strong>DNT：</strong><br>DNT: 1 首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下：</p>
<ul>
<li>0 ：同意被追踪</li>
<li>1 ：拒绝被追踪</li>
</ul>
<p>由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。</p>
<p><strong>P3P：</strong><br>P3P: CP&#x3D;”CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS IND 首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p>
<p><strong>要进行 P3P 的设定，需按以下操作步骤进行：</strong></p>
<ul>
<li>步骤 1：创建 P3P 隐私</li>
<li>步骤 2：创建 P3P 隐私对照文件后，保存命名在 &#x2F;w3c&#x2F;p3p.xml</li>
<li>步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中</li>
</ul>
<h2 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h2><table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>100 Continue</td>
<td>服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。</td>
</tr>
<tr>
<td>101 Switching Protocols</td>
<td>服务器转换协议：服务器将遵从客户的请求转换到另外一种协议。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>200 OK</td>
<td>请求成功（其后是对GET和POST请求的应答文档。）</td>
</tr>
<tr>
<td>201 Created</td>
<td>请求被创建完成，同时新的资源被创建。</td>
</tr>
<tr>
<td>202 Accepted</td>
<td>供处理的请求已被接受，但是处理未完成。</td>
</tr>
<tr>
<td>203 Non-authoritative Information</td>
<td>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝。</td>
</tr>
<tr>
<td>204 No Content</td>
<td>没有新文档。浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td>205 Reset Content</td>
<td>没有新文档。但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容。</td>
</tr>
<tr>
<td>206 Partial Content</td>
<td>客户发送了一个带有Range头的GET请求，服务器完成了它。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>300 Multiple Choices</td>
<td>多重选择。链接列表。用户可以选择某链接到达目的地。最多允许五个地址。</td>
</tr>
<tr>
<td>301 Moved Permanently</td>
<td>所请求的页面已经转移至新的url。</td>
</tr>
<tr>
<td>302 Found</td>
<td>所请求的页面已经临时转移至新的url。</td>
</tr>
<tr>
<td>303 See Other</td>
<td>所请求的页面可在别的url下被找到。</td>
</tr>
<tr>
<td>304 Not Modified</td>
<td>未按预期修改文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td>305 Use Proxy</td>
<td>客户请求的文档应该通过Location头所指明的代理服务器提取。</td>
</tr>
<tr>
<td>306 <em>Unused</em></td>
<td>此代码被用于前一版本。目前已不再使用，但是代码依然被保留。</td>
</tr>
<tr>
<td>307 Temporary Redirect</td>
<td>被请求的页面已经临时移至新的url。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>400 Bad Request</td>
<td>服务器未能理解请求。</td>
</tr>
<tr>
<td>401 Unauthorized</td>
<td>被请求的页面需要用户名和密码。</td>
</tr>
<tr>
<td>401.1</td>
<td>登录失败。</td>
</tr>
<tr>
<td>401.2</td>
<td>服务器配置导致登录失败。</td>
</tr>
<tr>
<td>401.3</td>
<td>由于 ACL 对资源的限制而未获得授权。</td>
</tr>
<tr>
<td>401.4</td>
<td>筛选器授权失败。</td>
</tr>
<tr>
<td>401.5</td>
<td>ISAPI&#x2F;CGI 应用程序授权失败。</td>
</tr>
<tr>
<td>401.7</td>
<td>访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>402 Payment Required</td>
<td>此代码尚无法使用。</td>
</tr>
<tr>
<td>403 Forbidden</td>
<td>对被请求页面的访问被禁止。</td>
</tr>
<tr>
<td>403.1</td>
<td>执行访问被禁止。</td>
</tr>
<tr>
<td>403.2</td>
<td>读访问被禁止。</td>
</tr>
<tr>
<td>403.3</td>
<td>写访问被禁止。</td>
</tr>
<tr>
<td>403.4</td>
<td>要求 SSL。</td>
</tr>
<tr>
<td>403.5</td>
<td>要求 SSL 128。</td>
</tr>
<tr>
<td>403.6</td>
<td>IP 地址被拒绝。</td>
</tr>
<tr>
<td>403.7</td>
<td>要求客户端证书。</td>
</tr>
<tr>
<td>403.8</td>
<td>站点访问被拒绝。</td>
</tr>
<tr>
<td>403.9</td>
<td>用户数过多。</td>
</tr>
<tr>
<td>403.10</td>
<td>配置无效。</td>
</tr>
<tr>
<td>403.11</td>
<td>密码更改。</td>
</tr>
<tr>
<td>403.12</td>
<td>拒绝访问映射表。</td>
</tr>
<tr>
<td>403.13</td>
<td>客户端证书被吊销。</td>
</tr>
<tr>
<td>403.14</td>
<td>拒绝目录列表。</td>
</tr>
<tr>
<td>403.15</td>
<td>超出客户端访问许可。</td>
</tr>
<tr>
<td>403.16</td>
<td>客户端证书不受信任或无效。</td>
</tr>
<tr>
<td>403.17</td>
<td>客户端证书已过期或尚未生效。</td>
</tr>
<tr>
<td>403.18</td>
<td>在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>403.19</td>
<td>不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>403.20</td>
<td>Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>404 Not Found</td>
<td>服务器无法找到被请求的页面。</td>
</tr>
<tr>
<td>404.0</td>
<td>（无）–没有找到文件或目录。</td>
</tr>
<tr>
<td>404.1</td>
<td>无法在所请求的端口上访问 Web 站点。</td>
</tr>
<tr>
<td>404.2</td>
<td>Web 服务扩展锁定策略阻止本请求。</td>
</tr>
<tr>
<td>404.3</td>
<td>MIME 映射策略阻止本请求。</td>
</tr>
<tr>
<td>405 Method Not Allowed</td>
<td>请求中指定的方法不被允许。</td>
</tr>
<tr>
<td>406 Not Acceptable</td>
<td>服务器生成的响应无法被客户端所接受。</td>
</tr>
<tr>
<td>407 Proxy Authentication Required</td>
<td>用户必须首先使用代理服务器进行验证，这样请求才会被处理。</td>
</tr>
<tr>
<td>408 Request Timeout</td>
<td>请求超出了服务器的等待时间。</td>
</tr>
<tr>
<td>409 Conflict</td>
<td>由于冲突，请求无法被完成。</td>
</tr>
<tr>
<td>410 Gone</td>
<td>被请求的页面不可用。</td>
</tr>
<tr>
<td>411 Length Required</td>
<td>“Content-Length” 未被定义。如果无此内容，服务器不会接受请求。</td>
</tr>
<tr>
<td>412 Precondition Failed</td>
<td>请求中的前提条件被服务器评估为失败。</td>
</tr>
<tr>
<td>413 Request Entity Too Large</td>
<td>由于所请求的实体的太大，服务器不会接受请求。</td>
</tr>
<tr>
<td>414 Request-url Too Long</td>
<td>由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况。</td>
</tr>
<tr>
<td>415 Unsupported Media Type</td>
<td>由于媒介类型不被支持，服务器不会接受请求。</td>
</tr>
<tr>
<td>416 Requested Range Not Satisfiable</td>
<td>服务器不能满足客户在请求中指定的Range头。</td>
</tr>
<tr>
<td>417 Expectation Failed</td>
<td>执行失败。</td>
</tr>
<tr>
<td>423</td>
<td>锁定的错误。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><strong>消息</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>500 Internal Server Error</td>
<td>请求未完成。服务器遇到不可预知的情况。</td>
</tr>
<tr>
<td>500.12</td>
<td>应用程序正忙于在 Web 服务器上重新启动。</td>
</tr>
<tr>
<td>500.13</td>
<td>Web 服务器太忙。</td>
</tr>
<tr>
<td>500.15</td>
<td>不允许直接请求 Global.asa。</td>
</tr>
<tr>
<td>500.16</td>
<td>UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>500.18</td>
<td>URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。</td>
</tr>
<tr>
<td>500.100</td>
<td>内部 ASP 错误。</td>
</tr>
<tr>
<td>501 Not Implemented</td>
<td>请求未完成。服务器不支持所请求的功能。</td>
</tr>
<tr>
<td>502 Bad Gateway</td>
<td>请求未完成。服务器从上游服务器收到一个无效的响应。</td>
</tr>
<tr>
<td>502.1</td>
<td>CGI 应用程序超时。　·</td>
</tr>
<tr>
<td>502.2</td>
<td>CGI 应用程序出错。</td>
</tr>
<tr>
<td>503 Service Unavailable</td>
<td>请求未完成。服务器临时过载或宕机。</td>
</tr>
<tr>
<td>504 Gateway Timeout</td>
<td>网关超时。</td>
</tr>
<tr>
<td>505 HTTP Version Not Supported</td>
<td>服务器不支持请求中指明的HTTP协议版本。</td>
</tr>
</tbody></table>
<h2 id="HTTP-报文实体"><a href="#HTTP-报文实体" class="headerlink" title="HTTP 报文实体"></a>HTTP 报文实体</h2><h3 id="HTTP-报文实体概述"><a href="#HTTP-报文实体概述" class="headerlink" title="HTTP 报文实体概述"></a>HTTP 报文实体概述</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/160444jrcu77utb4fg1733.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.png"></p>
<p>大家请仔细看看上面示例中，各个组成部分对应的内容。</p>
<p>接着，我们来看看报文和实体的概念。如果把 HTTP 报文想象成因特网货运系统中的箱子，那么 HTTP 实体就是报文中实际的货物。</p>
<ul>
<li>报文：是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变；</li>
<li>实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。（实体首部相关内容在上面第六点中已有阐述。）</li>
</ul>
<p>我们可以看到，上面示例右图中深红色框的内容就是报文的实体部分，而蓝色框的两部分内容分别就是实体首部和实体主体。而左图中粉红框内容就是报文主体。<br>通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>HTTP 应用程序有时在发送之前需要对内容进行编码。例如，在把很大的 HTML 文档发送给通过慢速连接上来的客户端之前，服务器可能会对其进行压缩，这样有助于减少传输实体的时间。服务器还可以把内容搅乱或加密，以此来防止未授权的第三方看到文档的内容。</p>
<p>这种类型的编码是在发送方应用到内容之上的。当内容经过内容编码后，编好码的数据就放在实体主体中，像往常一样发送给接收方。</p>
<p><strong>内容编码类型：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/160922rjfhtzvhqdrt3vt1.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.jpg"></p>
<h3 id="传输编码"><a href="#传输编码" class="headerlink" title="传输编码"></a>传输编码</h3><p>内容编码是对报文的主体进行的可逆变换，是和内容的具体格式细节紧密相关的。</p>
<p>传输编码也是作用在实体主体上的可逆变换，但使用它们是由于架构方面的原因，同内容的格式无关。使用传输编码是为了改变报文中的数据在网络上传输的方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/160702eehbcpfzfpq1fceo.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.png"></p>
<h3 id="分块编码"><a href="#分块编码" class="headerlink" title="分块编码"></a>分块编码</h3><p>分块编码把报文分割成若干已知大小的块。块之间是紧挨着发送的，这样就不需要在发送之前知道整个报文的大小了。分块编码是一种传输编码，是报文的属性。</p>
<p>若客户端与服务器端之间不是持久连接，客户端就不需要知道它在读取的主体的长度，而只需要读取到服务器关闭主体连接为止。</p>
<p>当使用持久连接时，在服务器写主体之前，必须知道它的大小并在 Content-Length 首部中发送。如果服务器动态创建内容，就可能在发送之前无法知道主体的长度。<br>分块编码为这种困难提供了解决方案，只要允许服务器把主体分块发送，说明每块的大小就可以了。因为主体是动态创建的，服务器可以缓冲它的一部分，发送其大小和相应的块，然后在主体发送完之前重复这个过程。服务器可以用大小为 0 的块作为主体结束的信号，这样就可以继续保持连接，为下一个响应做准备。</p>
<p><strong>来看看一个分块编码的报文示例：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/161011bzsn1hzlt3nxgp3h.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png"></p>
<h3 id="多部分媒体类型"><a href="#多部分媒体类型" class="headerlink" title="多部分媒体类型"></a>多部分媒体类型</h3><p>MIME 中的 multipart（多部分）电子邮件报文中包含多个报文，它们合在一起作为单一的复杂报文发送。每一部分都是独立的，有各自的描述其内容的集，不同部分之间用分界字符串连接在一起。<br>相应得，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可包含多种类型实体。</p>
<p><strong>多部分对象集合包含的对象如下：</strong></p>
<ul>
<li>multipart&#x2F;form-data：在 Web 表单文件上传时使用；</li>
<li>multipart&#x2F;byteranges：状态码 206 Partial Content 响应报文包含了多个范围的内容时使用。</li>
</ul>
<h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>假设你正在下载一个很大的文件，已经下了四分之三，忽然网络中断了，那下载就必须重头再来一遍。为了解决这个问题，需要一种可恢复的机制，即能从之前下载中断处恢复下载。要实现该功能，这就要用到范围请求。</p>
<p>有了范围请求， HTTP 客户端可以通过请求曾获取失败的实体的一个范围（或者说一部分），来恢复下载该实体。当然这有一个前提，那就是从客户端上一次请求该实体到这一次发出范围请求的时间段内，该对象没有改变过。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /bigfile.html HTTP/1.1``Host: [url=http://www.sample.com]www.sample.com[/url]``Range: bytes=20224-``···</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/161118euqf4c6mm63dcx6o.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.png"></p>
<p>上面示例中，客户端请求的是文档开头20224字节之后的部分。</p>
<h2 id="与-HTTP-协作的-Web-服务器"><a href="#与-HTTP-协作的-Web-服务器" class="headerlink" title="与 HTTP 协作的 Web 服务器"></a>与 HTTP 协作的 Web 服务器</h2><p>HTTP 通信时，除客户端和服务器外，还有一些用于协助通信的应用程序。如下列出比较重要的几个：代理、缓存、网关、隧道、Agent 代理。</p>
<h3 id="13-1代理"><a href="#13-1代理" class="headerlink" title="13.1代理"></a>13.1代理</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162650imtunuu1moagmajm.jpg" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_1.jpg"></p>
<p>HTTP 代理服务器是 Web 安全、应用集成以及性能优化的重要组成模块。代理位于客户端和服务器端之间，接收客户端所有的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后再进行转发）。对用户来说，这些应用程序就是一个代理，代表用户访问服务器。</p>
<p>出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤，安全上网或绿色上网。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>浏览器第一次请求：</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162745p1cm8xqa6aczttvq.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_2.png"></p>
<p>浏览器再次请求：</p>
<p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162757l6llgpk844ht4wjt.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_3.png"></p>
<p>Web 缓存或代理缓存是一种特殊的 HTTP 代理服务器，可以将经过代理传输的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务了。客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162822u9kop17v57v7v1kw.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_4.png"></p>
<p>网关是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接收请求时就好像自己是资源的源服务器一样。客户端可能并不知道自己正在跟一个网关进行通信。</p>
<h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162831nzz7vototoi1zoww.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_5.png"></p>
<p>隧道是会在建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。<br>HTTP 隧道的一种常见用途就是通过 HTTP 连接承载加密的安全套接字层（SSL）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。</p>
<h3 id="Agent-代理"><a href="#Agent-代理" class="headerlink" title="Agent 代理"></a>Agent 代理</h3><p><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/162909jj4mec4ysjrp39je.png" alt="网络编程懒人入门(七)：深入浅出，全面理解HTTP协议_6.png"></p>
<p>Agent 代理是代表用户发起 HTTP 请求的客户端应用程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。</p>
<p>（原文链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6e9e4156ece3%EF%BC%89">https://www.jianshu.com/p/6e9e4156ece3）</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">KNeegcyao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/posts/b0dbfb54.html">http://example.com/posts/b0dbfb54.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">KNeegcyao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></div><div class="post-share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&amp;riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&amp;ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/36e4fc8d.html" title="网络编程懒人入门(八):手把手教你写基于TCP的Socket长连接"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&amp;riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&amp;ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">网络编程懒人入门(八):手把手教你写基于TCP的Socket长连接</div></div><div class="info-2"><div class="info-item-1">引言好多小白初次接触即时通讯（比如：IM或者消息推送应用）时，总是不能理解Web短连接（就是最常见的HTTP通信了）跟长连接（主要指TCP、UDP协议实现的socket通信，当然HTML5里的Websocket协议也是长连接）的区别，导致写即时通讯这类系统代码时往往找不到最佳实践，搞的一脸蒙逼。 本篇我们先简单了解一下 TCP&#x2F;IP，然后通过实现一个 echo 服务器来学习 Java 的 Socket API。最后我们聊聊偏高级一点点的 socket 长连接和协议设计。 另外，本系列文章的前2篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》、《网络编程懒人入门(二)：快速理解网络通信协议（下篇）》快速介绍了网络基本通信协议及理论基础，如果您对网络基础毫无概念，则请务必首先阅读完这2篇文章。本系列的第3篇文章《网络编程懒人入门(三)：快速理解TCP协议一篇就够》有助于您快速理解TCP协议理论的方方面面，建议也可以读一读。 TCP...</div></div></div></a><a class="pagination-related" href="/posts/eb6629b4.html" title="网络编程懒人入门(六):史上最通俗的集线器、交换机、路由器功能原理入门"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&amp;riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&amp;ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">网络编程懒人入门(六):史上最通俗的集线器、交换机、路由器功能原理入门</div></div><div class="info-2"><div class="info-item-1">前言即时通讯网整理了大量的网络编程类基础文章和资料，包括《TCP&#x2F;IP协议...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/4ed1237b.html" title="搞懂Cookie,Session,Token三种认证授权方式"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/image-20241216163229547.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-16</div><div class="info-item-2">搞懂Cookie,Session,Token三种认证授权方式</div></div><div class="info-2"><div class="info-item-1">Cookie，Seesion和Token区别及用途 简介Cookie、Session、Token 和 JWT（JSON Web Token）都是用于在网络应用中进行身份验证和状态管理的机制。虽然它们有一些相似之处，但在实际应用中有着不同的作用和特点。 Cookie定义：  HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。 cookie 存储在客户端：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。 cookie 是不可跨域的：每个 cookie...</div></div></div></a><a class="pagination-related" href="/posts/6c92115f.html" title="Spring"><img class="cover" src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/20241206224728342.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-04</div><div class="info-item-2">Spring</div></div><div class="info-2"><div class="info-item-1">Spring介绍Spring是一个IOC（DI）和AOP框架Spring的优良特性  ·非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API  ·依赖注入：DI是控制反转（IOC）最经典的实现  ·面向切面编程：AOP  ·组件化：Spring通过众多简单的组件配置组合成一个复杂应用  ·一站化：Spring提供了一系列框架，解决了应用开发中的众多问题 Spring模块划分  Spring-IOC容器组件和容器  ·组件：具有一定功能的对象。  ·容器：管理组件（创建，获取，保存，销毁）   可以将组件和容器的关系比喻成“房间”与“家具”的关系：   组件：可以看作是各种“家具”，比如桌子、椅子、灯、书架等。它们是构成界面或应用功能的基本元素，完成特定的功能任务，比如显示文本、输入数据等。  容器：则是“房间”或“空间”，用于装下各种家具。容器负责管理组件的布局、位置和相互之间的关系，同时也可能控制组件的生命周期和事件传递。  常见的容器：Servlet 容器（如 Tomcat、Jetty）：用于管理和运行 Java Web 应用，处理 HTTP...</div></div></div></a><a class="pagination-related" href="/posts/a90dbf1.html" title="网络编程懒人入门(三):快速理解TCP协议一篇就够"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">网络编程懒人入门(三):快速理解TCP协议一篇就够</div></div><div class="info-2"><div class="info-item-1">前言本系列文章的前两篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》、《网络编程懒人入门(二)：快速理解网络通信协议（下篇）》快速介绍了网络基本通信协议及理论基础，建议开始阅读本文前先读完此2篇文章。 TCP 是互联网的核心协议之一，鉴于它的重要性，本文将单独介绍它的基础知识，希望能加深您对TCP协议的理解。 老规矩，为了让文字尽量通俗易懂、不浪费你的脑细胞，本文尽量点到为止，不对理论进行深入挖掘，如需深入理论细节，请参见下方参考资料中有关TCP协议的详细介绍和学习文章。 群神镇楼：  TCP 协议的作用互联网由一整套协议构成。TCP 只是其中的一层，有着自己的分工。  ▲ TCP 是以太网协议和 IP 协议的上层协议，也是应用层协议的下层协议 最底层的以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。  ▲ 以太网协议解决了局域网的点对点通信 但是，以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。  ▲ IP 协议可以连接多个局域网 IP 协议定义了一套自己的地址规则，称为 IP...</div></div></div></a><a class="pagination-related" href="/posts/7b1a8364.html" title="网络编程懒人入门(二):快速理解网络通信协议（下篇）"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">网络编程懒人入门(二):快速理解网络通信协议（下篇）</div></div><div class="info-2"><div class="info-item-1">前言本文上篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》分析了互联网的总体构思，从下至上，每一层协议的设计思想。基于知识连贯性的考虑，建议您先看完上篇后再来阅读本文。 本文从设计者的角度看问题，今天我想切换到用户的角度，看看用户是如何从上至下，与这些协议互动的。 一个小结先对前面的内容，做一个小结（详见本文上篇《网络编程懒人入门(一)：快速理解网络通信协议（上篇）》）。 我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。 数据包的结构，基本上是下面这样：  发送这个包，需要知道两个地址：  * 对方的MAC地址； *...</div></div></div></a><a class="pagination-related" href="/posts/25b12d17.html" title="网络编程懒人入门(一):快速理解网络通信协议（上篇）"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">网络编程懒人入门(一):快速理解网络通信协议（上篇）</div></div><div class="info-2"><div class="info-item-1">正文引言【特别声明】：转自即使通讯网 我们每天使用互联网，你是否想过，它是如何实现的？ 全世界几十亿台电脑，连接在一起，两两通信。上海的某一块网卡送出信号，洛杉矶的另一块网卡居然就收到了，两者实际上根本不知道对方的物理位置，你不觉得这是很神奇的事情吗？ 互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol...</div></div></div></a><a class="pagination-related" href="/posts/2de5e4a.html" title="网络编程懒人入门(九):通俗讲解，有了IP地址，为何还要用MAC地址？"><img class="cover" src="https://ts1.cn.mm.bing.net/th/id/R-C.5a39c299f3ced2c10b1e76183339c73e?rik=y1GjYN9iv1utPw&riu=http%3a%2f%2fimg.aiimg.com%2fuploads%2fuserup%2f0909%2f1102045635U.jpg&ehk=FmHrFX4Y2W1j2BOzHgGIDqMdZZtwbi48iYjATaOCDko%3d&risl=&pid=ImgRaw&r=0" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="info-item-2">网络编程懒人入门(九):通俗讲解，有了IP地址，为何还要用MAC地址？</div></div><div class="info-2"><div class="info-item-1">前言标题虽然是为了解释有了 IP 地址，为什么还要用 MAC 地址，但是本文的重点在于理解为什么要有 IP 这样的东西。本文对读者的定位是知道 MAC 地址是什么，IP 地址是什么。 关于作者 翟志军，个人博客地址：https://showme.codes/，Github：https://github.com/zacker330。感谢作者的原创分享。 书上说的*基本概念：* 如今的网络是分层来实现的，就像是搭积木一样，先设计某个特定功能的模块，然后把模块拼起来组成整个网络。局域网也不例外，一般来说，在组网上我们使用的是[IEEE802](https://baike.baidu.com/item/IEEE...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/dbec14fc4bb3795ba2556e8a82eaee0f.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">KNeegcyao</div><div class="author-info-description">记录coding！</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/KNeegcyao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/KNeegcyao" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:zhangchao2903@163.com.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=322815684" target="_blank" title="云音乐"><i class="fa-solid fa-music"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9CHTTP%E4%B9%8B%E7%88%B6%E2%80%9D%E5%85%B6%E4%BA%BA"><span class="toc-number">2.</span> <span class="toc-text">“HTTP之父”其人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E6%A6%82%E8%BF%B0"><span class="toc-number">3.</span> <span class="toc-text">HTTP概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82"><span class="toc-number">3.1.</span> <span class="toc-text">计算机网络体系结构分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP-%E9%80%9A%E4%BF%A1%E4%BC%A0%E8%BE%93%E6%B5%81"><span class="toc-number">3.2.</span> <span class="toc-text">TCP&#x2F;IP 通信传输流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">HTTP 工作过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80"><span class="toc-number">5.</span> <span class="toc-text">HTTP 协议基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E7%9A%84%E4%BA%A4%E6%8D%A2%E8%BE%BE%E6%88%90%E9%80%9A%E4%BF%A1"><span class="toc-number">5.1.</span> <span class="toc-text">通过请求和响应的交换达成通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">HTTP 是不保存状态的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Cookie-%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">使用 Cookie 的状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82-URI-%E5%AE%9A%E4%BD%8D%E8%B5%84%E6%BA%90"><span class="toc-number">5.4.</span> <span class="toc-text">请求 URI 定位资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%84%8F%E5%9B%BE%E7%9A%84-HTTP-%E6%96%B9%E6%B3%95%EF%BC%88HTTP-1-1%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">告知服务器意图的 HTTP 方法（HTTP&#x2F;1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.6.</span> <span class="toc-text">持久连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="toc-number">5.7.</span> <span class="toc-text">管线化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">HTTP 协议报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87"><span class="toc-number">6.1.</span> <span class="toc-text">HTTP 报文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">HTTP 报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">请求报文结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.</span> <span class="toc-text">响应报文结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8%E4%B9%8B%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%88%E9%87%8D%E7%82%B9%E5%88%86%E6%9E%90%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">HTTP 报文首部之首部字段（重点分析）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">首部字段概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">首部字段结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.3.</span> <span class="toc-text">首部字段类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%88HTTP-1-1%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">通用首部字段（HTTP&#x2F;1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%88HTTP-1-1%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">请求首部字段（HTTP&#x2F;1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%88HTTP-1-1%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">响应首部字段（HTTP&#x2F;1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5%EF%BC%88HTTP-1-1%EF%BC%89"><span class="toc-number">7.7.</span> <span class="toc-text">实体首部字段（HTTP&#x2F;1.1）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA-Cookie-%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">7.8.</span> <span class="toc-text">为 Cookie 服务的首部字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5"><span class="toc-number">8.</span> <span class="toc-text">其他首部字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">9.</span> <span class="toc-text">HTTP 响应状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E5%AE%9E%E4%BD%93"><span class="toc-number">10.</span> <span class="toc-text">HTTP 报文实体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E6%8A%A5%E6%96%87%E5%AE%9E%E4%BD%93%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">HTTP 报文实体概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81"><span class="toc-number">10.2.</span> <span class="toc-text">内容编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81"><span class="toc-number">10.3.</span> <span class="toc-text">传输编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E7%BC%96%E7%A0%81"><span class="toc-number">10.4.</span> <span class="toc-text">分块编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%83%A8%E5%88%86%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.5.</span> <span class="toc-text">多部分媒体类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82"><span class="toc-number">10.6.</span> <span class="toc-text">范围请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-HTTP-%E5%8D%8F%E4%BD%9C%E7%9A%84-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">与 HTTP 协作的 Web 服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1%E4%BB%A3%E7%90%86"><span class="toc-number">11.1.</span> <span class="toc-text">13.1代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">11.2.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E5%85%B3"><span class="toc-number">11.3.</span> <span class="toc-text">网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%A7%E9%81%93"><span class="toc-number">11.4.</span> <span class="toc-text">隧道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Agent-%E4%BB%A3%E7%90%86"><span class="toc-number">11.5.</span> <span class="toc-text">Agent 代理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/8b63f587.html" title="Docker基础入门"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/main_hu47e299bfffaad059de349ef77bc2cb77_42796_1600x0_resize_box_3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker基础入门"/></a><div class="content"><a class="title" href="/posts/8b63f587.html" title="Docker基础入门">Docker基础入门</a><time datetime="2025-05-10T07:44:52.000Z" title="发表于 2025-05-10 15:44:52">2025-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/581c43cc.html" title="SpringSecurity框架入门"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/springsecurity-1024x538-1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity框架入门"/></a><div class="content"><a class="title" href="/posts/581c43cc.html" title="SpringSecurity框架入门">SpringSecurity框架入门</a><time datetime="2025-04-06T08:19:43.000Z" title="发表于 2025-04-06 16:19:43">2025-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d2dd85e5.html" title="常见排序算法比较"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/image-20250327104247539.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见排序算法比较"/></a><div class="content"><a class="title" href="/posts/d2dd85e5.html" title="常见排序算法比较">常见排序算法比较</a><time datetime="2025-03-27T06:04:56.000Z" title="发表于 2025-03-27 14:04:56">2025-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/93c6a719.html" title="深入浅出消息队列(RabbitMQ)"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/image.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入浅出消息队列(RabbitMQ)"/></a><div class="content"><a class="title" href="/posts/93c6a719.html" title="深入浅出消息队列(RabbitMQ)">深入浅出消息队列(RabbitMQ)</a><time datetime="2025-03-14T14:44:55.000Z" title="发表于 2025-03-14 22:44:55">2025-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/69de8254.html" title="拦截器Interceptor与过滤器Filter"><img src="https://cdn.jsdelivr.net/gh/KNeegcyao/picdemo/img/4645f616a8feb588fbc802acda2f7c5e.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="拦截器Interceptor与过滤器Filter"/></a><div class="content"><a class="title" href="/posts/69de8254.html" title="拦截器Interceptor与过滤器Filter">拦截器Interceptor与过滤器Filter</a><time datetime="2024-12-25T06:24:59.000Z" title="发表于 2024-12-25 14:24:59">2024-12-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://haowallpaper.com/link/common/file/previewFileImg/f351ca6264cb84d5053926824a04634af351ca6264cb84d5053926824a04634a);"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By KNeegcyao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: '',
      owner: '',
      admin: [''],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '4a6cd0ee1ee87e3159677b3f4c29a001'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.8" zIndex="-1" count="200" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="Java,Spring,k8s,MVC,Redis,Mysql,JVM,Maven,Docker" data-fontsize="15px" data-random="true" async="async"></script><script>(() => {
  const isChatBtn = false
  const isChatHideShow = false

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = { startHidden: true }
  
    window.chatBtnFn = () => {
      document.getElementById('chatra').classList.contains('chatra--expanded') ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => Chatra('hide'),
      show: () => Chatra('show')
    }
  }

  (function(d, w, c) {
    w.ChatraID = ''
    var s = d.createElement('script')
    w[c] = w[c] || function() {
      (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>